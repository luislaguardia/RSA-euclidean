from sympy import mod_inverse
from sympy.ntheory import isprime

# Given values
c = 30799623142724830428134771008774390881460367194180049770617479901591091484591391500858137510867287877342653943804928164707846331839143915672730906056617147012428680844976482183492261655523056337339390942259568877248040620902843834757375278079349955880905114854509612475407520861544225725514664260341618660142
n = 66162734470397639929895334547153582871789109310109808226194873261434341609762372608106100870489807600684436835690151747789231905775061265117863474548210288394265949168753204937477698085137930480033498602383227967171466777365559934660792726075125884854414870261501376573981953429422415034945771535881963371639
e = 57325152988885502664742767926377800268684880204403088949876001165815130683844802230893826780734893952876457220211390309210307998621012616036554033222012357502159286260078575811710163042025394830810498140672344153439146493876289499594044393060927442653258971083672557141642947489014255351176540185795781515833

# To decrypt, we need to find d first, which might be provided or might need calculating. For this example, we assume d is known or calculateable.
# d = mod_inverse(e, phi(n))  # If phi(n) is known or calculable

# For demonstration, we'll need to know 'd'. In practice, this would require factoring 'n' to find phi(n), then finding d.

# Example function for decryption if d was known:
def decrypt(c, d, n):
    return pow(c, d, n)

# Example usage (this won't work without a known 'd'):
# decrypted_message = decrypt(c, d, n)
# print(decrypted_message)
